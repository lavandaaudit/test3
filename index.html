<!DOCTYPE html>
<html lang="uk">
<head>
<meta charset="UTF-8">
<title>GEOMETRIC CHAOS · DATA STREAM</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<style>
html, body {
  margin:0;
  padding:0;
  width:100%;
  height:100%;
  background:#000;
  overflow:hidden;
  font-family:"Courier New", monospace;
  color:#9fe7ff;
}
canvas { display:block; position:fixed; inset:0; z-index:0; }
#panel{
  position:fixed;
  top:0;
  left:0;
  width:260px;
  height:100%;
  background:rgba(0,0,0,0.6);
  border-right:1px solid rgba(0,200,255,0.2);
  padding:12px;
  box-sizing:border-box;
  z-index:2;
}
#panel h1{
  font-size:13px;
  margin:0 0 8px 0;
  font-weight:normal;
  letter-spacing:1px;
}
#data{
  font-size:11px;
  line-height:1.4;
  white-space:pre;
  margin-bottom:12px;
  max-height:180px;
  overflow-y:auto;
}
#info{
  position:fixed;
  bottom:8px;
  left:50%;
  transform:translateX(-50%);
  font-size:10px;
  opacity:0.35;
  text-align:center;
  max-width:90%;
  z-index:2;
}
</style>
</head>
<body>

<canvas id="c"></canvas>

<div id="panel">
  <h1>PHYSICAL DATA STREAM</h1>
  <div id="data"></div>
</div>

<div id="info">
фізико-геометрична система. симуляція реальних та модельованих даних. кожен показник — окремий потік.
</div>

<script>
/* ===================== CANVAS ===================== */
const canvas = document.getElementById("c");
const ctx = canvas.getContext("2d");
let w, h;
function resize(){ w=canvas.width=innerWidth; h=canvas.height=innerHeight; }
window.addEventListener("resize", resize);
resize();

/* ===================== DATA ===================== */
const data = {
  seismic:0.3,
  magnetic:0.4,
  atmosphere_wind:0.5,
  atmosphere_pressure:0.5,
  atmosphere_temp:0.5,
  ocean:0.5,
  solar_radiation:0.5,
  solar_wind:0.4,
  precipitation:0.3,
  chaos:0.35
};

/* ===================== HISTORY ===================== */
const history = {};
const HISTORY_LEN = 300;
for(const k in data) history[k] = [];

/* ===================== DATA UPDATE ===================== */
function updateData(){
  for(const k in data){
    data[k] += (Math.random()-0.5)*0.01;
    data[k] = Math.max(0, Math.min(1, data[k]));
    history[k].push(data[k]);
    if(history[k].length>HISTORY_LEN) history[k].shift();
  }
}

/* ===================== PANEL ===================== */
const dataDiv = document.getElementById("data");
function drawPanel(){
  let out="";
  for(const k in data){
    out += k.padEnd(22," ") + data[k].toFixed(2) + "\n";
  }
  dataDiv.textContent = out;
}

/* ===================== COLORS ===================== */
const colors = [
  "rgba(255,80,80,0.8)",
  "rgba(80,180,255,0.8)",
  "rgba(80,255,160,0.8)",
  "rgba(255,180,60,0.8)",
  "rgba(255,100,200,0.8)",
  "rgba(100,200,255,0.8)",
  "rgba(255,240,100,0.8)",
  "rgba(200,120,255,0.8)",
  "rgba(100,220,255,0.8)",
  "rgba(255,255,255,0.8)"
];

/* ===================== DRAW STREAM ===================== */
function drawStream(){
  ctx.fillStyle="rgba(0,0,0,0.15)";
  ctx.fillRect(0,0,w,h);

  const keys = Object.keys(history);
  keys.forEach((k,i)=>{
    const hData = history[k];
    ctx.beginPath();
    ctx.strokeStyle = colors[i%colors.length];
    ctx.lineWidth = 1.5;
    hData.forEach((v,j)=>{
      const x = (j/HISTORY_LEN)*w;
      const y = h*0.2 + i*(h*0.06) + (v*0.05*h); // верхня частина екрану, рух хвилеподібний
      if(j===0) ctx.moveTo(x,y);
      else ctx.lineTo(x,y);
    });
    ctx.stroke();
  });
}

/* ===================== LOOP ===================== */
function loop(){
  updateData();
  drawPanel();
  drawStream();
  requestAnimationFrame(loop);
}

loop();
</script>
</body>
</html>
