<!DOCTYPE html>
<html lang="uk">
<head>
<meta charset="UTF-8">
<title>GEOMETRIC CHAOS · DYNAMIC GEOMETRY</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<style>
html, body {
  margin:0; padding:0;
  background:#000;
  overflow:hidden;
  height:100%;
  font-family:'Courier New', monospace;
  color:#0af;
}
canvas { display:block; }
#hud {
  position:absolute;
  top:16px; left:16px;
  font-size:13px;
  opacity:0.7;
  pointer-events:none;
  letter-spacing:1px;
}
#data {
  position:absolute;
  bottom:16px; left:16px;
  font-size:10px;
  opacity:0.6;
  pointer-events:none;
  max-width:400px;
  line-height:1.4;
}
#data .real { color:#0f0; font-weight:bold; }
#data .fallback { color:#888; }
#data .warning { color:#ff0; }
#clock {
  position:absolute;
  bottom:16px; right:16px;
  font-size:11px;
  opacity:0.45;
  color:#6cf;
  text-align:right;
  pointer-events:none;
  line-height:1.3;
}
#status {
  position:absolute;
  top:40px; left:16px;
  font-size:11px;
  opacity:0.6;
  color:#0af;
}
</style>
</head>
<body>

<div id="hud">GEOMETRIC CHAOS — DYNAMIC GEOMETRY</div>
<div id="status"></div>
<div id="data">ініціалізація...</div>
<div id="clock">—</div>
<canvas id="c"></canvas>

<script>
/* ================== BASIC ================== */
const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d');
const dataDiv = document.getElementById('data');
const clockDiv = document.getElementById('clock');
const statusDiv = document.getElementById('status');

function resize(){
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;
}
window.addEventListener('resize', resize);
resize();

/* ================== TIME ================== */
const startTime = Date.now();
function formatRelativeTime(ms){
  const s = Math.floor(ms/1000);
  if(s<60) return `+${s}s`;
  const m = Math.floor(s/60), sec=s%60;
  if(m<60) return `+${m}m ${sec}s`;
  const h=Math.floor(m/60), min=m%60;
  return `+${h}h ${min}m`;
}
function updateClock(){
  const now=new Date();
  clockDiv.innerHTML =
    `${String(now.getHours()).padStart(2,'0')}:`+
    `${String(now.getMinutes()).padStart(2,'0')}:`+
    `${String(now.getSeconds()).padStart(2,'0')}<br>`+
    formatRelativeTime(Date.now()-startTime);
}
setInterval(updateClock,1000); updateClock();

/* ================== STARS ================== */
const stars=[];
for(let i=0;i<320;i++){
  stars.push({
    x:Math.random()*canvas.width,
    y:Math.random()*canvas.height,
    size:Math.random()*1.4+0.4,
    baseAlpha:Math.random()*0.4+0.25,
    twinkle:Math.random()*0.015+0.006
  });
}

/* ================== DATA ================== */
let realData={
  seismic:0.5,
  magnetic:0.5,
  atmosphere_wind:0.5,
  atmosphere_pressure:0.5,
  atmosphere_temp:0.5,
  ocean:0.5,
  solar_radiation:0.5,
  solar_wind:0.5,
  precipitation:0.5,
  chaos:0.5
};
let dataHistory={};
Object.keys(realData).forEach(k=>dataHistory[k]=[]);
let sources={};

/* ================== UTILS ================== */
function lerp(a,b,t){ return a+(b-a)*t; }

/* ======== GLOBAL INFLUENCE (ALL 10) ======== */
function globalInfluence(){
  const d=realData;
  return {
    timeScale:
      0.4 +
      d.atmosphere_temp*1.2 +
      d.solar_radiation*0.6 +
      d.chaos*0.9,

    distortion:
      d.seismic*0.6 +
      d.ocean*0.5 +
      d.chaos,

    turbulence:
      d.atmosphere_wind*0.7 +
      d.precipitation*0.6 +
      d.chaos*0.8,

    density:
      d.atmosphere_pressure*0.8 +
      d.magnetic*0.5,

    glow:
      d.solar_radiation*0.9 +
      d.solar_wind*0.6,

    fracture:
      d.solar_wind*0.7 +
      d.precipitation*0.6 +
      d.chaos,

    stability:
      1 - (d.chaos*0.6 + d.seismic*0.4)
  };
}

/* ================== FETCH REAL DATA ================== */
async function fetchRealPlanetData(){
  statusDiv.innerHTML='оновлення...';
  let loaded=0;
  try{
    const weatherUrl=
      `https://api.open-meteo.com/v1/forecast?latitude=50.55&longitude=30.25&current=`+
      `temperature_2m,wind_speed_10m,surface_pressure,precipitation,shortwave_radiation`;
    const wRes=await fetch(weatherUrl);
    if(wRes.ok){
      const w=(await wRes.json()).current||{};
      realData.atmosphere_temp=Math.min(1,Math.max(0,(w.temperature_2m+40)/80));
      realData.atmosphere_wind=Math.min(1,(w.wind_speed_10m||0)/80);
      realData.atmosphere_pressure=Math.min(1,Math.max(0,((w.surface_pressure||1013)-950)/150));
      realData.precipitation=Math.min(1,(w.precipitation||0)/15);
      realData.solar_radiation=Math.min(1,(w.shortwave_radiation||0)/1200);
      loaded+=5;
      sources.atmosphere_temp=
      sources.atmosphere_wind=
      sources.atmosphere_pressure=
      sources.precipitation=
      sources.solar_radiation=true;
    }

    const oceanRes=await fetch(
      `https://marine-api.open-meteo.com/v1/marine?latitude=44.5&longitude=34.0&current=wave_height`
    );
    if(oceanRes.ok){
      const o=(await oceanRes.json()).current||{};
      realData.ocean=Math.min(1,(o.wave_height||0)/8);
      loaded++; sources.ocean=true;
    }

    const eqRes=await fetch(
      'https://earthquake.usgs.gov/earthquakes/feed/v1.0/summary/all_hour.geojson'
    );
    if(eqRes.ok){
      const eq=await eqRes.json();
      const f=eq.features||[];
      const maxMag=f.reduce((m,x)=>Math.max(m,x.properties?.mag||0),0);
      realData.seismic=Math.min(1,(f.length/30)+(maxMag/10)*0.5);
      loaded++; sources.seismic=true;
    }

    const proxy='https://corsproxy.io/?';
    try{
      const solarRes=await fetch(
        proxy+encodeURIComponent(
          'https://services.swpc.noaa.gov/products/solar-wind/plasma-7-day.json'
        )
      );
      if(solarRes.ok){
        const d=await solarRes.json();
        const l=d[d.length-1]||[];
        const speed=parseFloat(l[3])||400;
        realData.solar_wind=Math.min(1,Math.max(0,(speed-250)/750));
        loaded++; sources.solar_wind=true;
      }
    }catch{}

    try{
      const kpRes=await fetch(
        proxy+encodeURIComponent(
          'https://services.swpc.noaa.gov/products/geospace/planetary-k-index-1-minute.json'
        )
      );
      if(kpRes.ok){
        const d=await kpRes.json();
        const kp=parseFloat(d[d.length-1]?.[1])||0;
        realData.magnetic=Math.min(1,kp/9);
        loaded++; sources.magnetic=true;
      }
    }catch{}

    Object.keys(realData).forEach(k=>{
      if(k==='chaos')return;
      dataHistory[k].push(realData[k]);
      if(dataHistory[k].length>80) dataHistory[k].shift();
    });

    let vars=[];
    Object.keys(dataHistory).forEach(k=>{
      if(k==='chaos')return;
      const h=dataHistory[k];
      if(h.length<2)return;
      const m=h.reduce((a,b)=>a+b,0)/h.length;
      const v=h.reduce((a,b)=>a+(b-m)**2,0)/h.length;
      vars.push(Math.sqrt(v));
    });
    realData.chaos=vars.length
      ?Math.min(1,vars.reduce((a,b)=>a+b,0)/vars.length*10)
      :0.5;

    let html='';
    Object.keys(realData).forEach(k=>{
      let cls='fallback';
      if(sources[k]===true) cls='real';
      else if(k!=='chaos') cls='warning';
      html+=`${k.padEnd(20,' ')} <span class="${cls}">${realData[k].toFixed(3)}</span><br>`;
    });
    dataDiv.innerHTML=html;
    statusDiv.innerHTML=loaded?'оновлено':'';
  }catch(e){ console.error(e); statusDiv.innerHTML=''; }
}
fetchRealPlanetData();
setInterval(fetchRealPlanetData,120000);

/* ================== LEFT GRAPH ================== */
function drawCoordinateSystem(){
  const margin=40, width=200, height=canvas.height-80;
  ctx.strokeStyle='#0af'; ctx.lineWidth=1;
  ctx.beginPath();
  ctx.moveTo(margin,40);
  ctx.lineTo(margin,height+40);
  ctx.lineTo(width+margin,height+40);
  ctx.stroke();
  ctx.fillStyle='#0af';
  ctx.font='11px Courier New';

  const keys=Object.keys(realData);
  keys.forEach((k,i)=>{
    const y=40+i*(height/(keys.length-1));
    ctx.fillText(k,5,y+3);
  });

  ctx.strokeStyle='rgba(0,255,150,0.6)';
  ctx.fillStyle='rgba(0,255,150,0.8)';
  let prev=null;
  keys.forEach((k,i)=>{
    const x=margin+realData[k]*width;
    const y=40+i*(height/(keys.length-1));
    ctx.beginPath();
    ctx.arc(x,y,5,0,Math.PI*2);
    ctx.fill();
    if(prev){
      ctx.beginPath();
      ctx.moveTo(prev.x,prev.y);
      ctx.lineTo(x,y);
      ctx.stroke();
    }
    prev={x,y};
  });
}

/* ================== MAIN LOOP ================== */
let t=0;
function loop(){
  const G=globalInfluence();
  t+=0.012*G.timeScale;

  ctx.globalCompositeOperation='source-over';
  ctx.fillStyle='rgba(0,0,0,0.08)';
  ctx.fillRect(0,0,canvas.width,canvas.height);

  const cx=canvas.width/2;
  const cy=canvas.height/2;

  /* STARS */
  stars.forEach(s=>{
    const n=Math.sin(t*s.twinkle*10+s.x*0.004*G.turbulence+s.y*0.004*G.distortion);
    const a=s.baseAlpha*(0.4+G.glow*0.6)+n*0.25;
    ctx.fillStyle=`rgba(220,235,255,${Math.max(0.05,a*G.stability)})`;
    ctx.fillRect(
      s.x+n*G.turbulence*2,
      s.y+n*G.turbulence*2,
      s.size,
      s.size
    );
  });

  /* POLYGONS */
  const layers=7;
  for(let i=0;i<layers;i++){
    const sides=3+i+Math.floor(realData.magnetic*4+realData.chaos*6);
    const r=
      120+
      80*G.distortion*Math.sin(t+i)+
      40*realData.ocean*Math.cos(t*0.7+i);
    const rot=t*0.2+i*0.5;
    ctx.beginPath();
    for(let s=0;s<sides;s++){
      const a=(Math.PI*2/sides)*s+rot;
      const noise=Math.sin(t+s*i);
      const x=cx+Math.cos(a+noise*G.turbulence)*r*(0.7+G.stability*0.6);
      const y=cy+Math.sin(a+noise*G.turbulence)*r*(0.7+G.stability*0.6);
      s===0?ctx.moveTo(x,y):ctx.lineTo(x,y);
    }
    ctx.closePath();
    ctx.strokeStyle=
      `rgba(${50+i*30},${100+i*20},${200-i*20},${0.1+realData.chaos*0.25})`;
    ctx.lineWidth=1.2+realData.magnetic*2;
    ctx.stroke();
  }

  /* SPIRAL */
  ctx.beginPath();
  for(let i=0;i<160;i++){
    const angle=i*0.2+t*0.6;
    const radius=
      i*0.9+
      60*realData.solar_wind*Math.sin(t*0.8+i*0.2)+
      50*realData.atmosphere_pressure+
      80*G.distortion;
    const x=cx+Math.cos(angle)*radius;
    const y=cy+Math.sin(angle)*radius;
    i===0?ctx.moveTo(x,y):ctx.lineTo(x,y);
  }
  ctx.strokeStyle=
    `rgba(${200+realData.solar_radiation*55},${120+realData.atmosphere_temp*80},${255-realData.precipitation*120},${0.05+G.glow*0.25})`;
  ctx.lineWidth=1.5;
  ctx.stroke();

  if(realData.chaos>0.6) ctx.globalCompositeOperation='lighter';

  drawCoordinateSystem();
  requestAnimationFrame(loop);
}
loop();
</script>
</body>
</html>
