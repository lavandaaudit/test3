<!DOCTYPE html>
<html lang="uk">
<head>
<meta charset="UTF-8">
<title>GEOMETRIC CHAOS · ENERGY FLOW</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<style>
html, body{
  margin:0; padding:0;
  width:100%; height:100%;
  background:#000;
  overflow:hidden;
  font-family:"Courier New", monospace;
  color:#0af;
}
canvas{ display:block; position:fixed; inset:0; z-index:0; }
#dataPanel{
  position:fixed;
  bottom:0; left:50%;
  transform:translateX(-50%);
  width:95%; max-width:900px;
  background:rgba(0,0,0,0.5);
  color:#0f0; font-size:11px;
  padding:6px 12px;
  border-radius:6px;
  line-height:1.2;
  z-index:2;
  white-space:pre;
}
#info{
  position:fixed;
  bottom:50px; left:50%;
  transform:translateX(-50%);
  font-size:10px; opacity:0.35;
  text-align:center;
  max-width:90%;
  z-index:2;
  color:#9fe7ff;
}
</style>
</head>
<body>

<canvas id="c"></canvas>
<div id="dataPanel">ініціалізація...</div>
<div id="info">
фізико-геометрична система. симуляція реальних даних планети. кожен показник — окремий потік, який “дихає”.
</div>

<script>
/* ===================== CANVAS ===================== */
const canvas=document.getElementById("c");
const ctx=canvas.getContext("2d");
let w,h;
function resize(){ w=canvas.width=innerWidth; h=canvas.height=innerHeight; }
window.addEventListener("resize",resize);
resize();

/* ===================== STARS ===================== */
const stars=[];
for(let i=0;i<400;i++){
  stars.push({
    x:Math.random()*w,
    y:Math.random()*h,
    size:Math.random()*1.5+0.5,
    baseAlpha:Math.random()*0.4+0.2,
    twinkle:Math.random()*0.02+0.005
  });
}

/* ===================== DATA ===================== */
const dataKeys = [
  "seismic","magnetic","atmosphere_wind","atmosphere_pressure","atmosphere_temp",
  "ocean","solar_radiation","solar_wind","precipitation","chaos"
];
const data={};
const history={};
const HISTORY_LEN=300;
dataKeys.forEach(k=>{data[k]=0.5; history[k]=[];});

/* ===================== COLORS ===================== */
const colors=[
  "rgba(255,80,80,0.8)","rgba(80,180,255,0.8)","rgba(80,255,160,0.8)",
  "rgba(255,180,60,0.8)","rgba(255,100,200,0.8)","rgba(100,200,255,0.8)",
  "rgba(255,240,100,0.8)","rgba(200,120,255,0.8)","rgba(100,220,255,0.8)",
  "rgba(255,255,255,0.8)"
];

/* ===================== DATA PANEL ===================== */
const dataPanel = document.getElementById("dataPanel");
function updatePanel(){
  let out="";
  dataKeys.forEach(k=>{
    out += k.padEnd(20," ") + data[k].toFixed(3) + "\n";
  });
  dataPanel.textContent = out;
}

/* ===================== DATA FETCH ===================== */
async function fetchData(){
  try{
    // Атмосфера
    const weatherRes = await fetch(`https://api.open-meteo.com/v1/forecast?latitude=50.55&longitude=30.25&current_weather=true&hourly=temperature_2m,wind_speed_10m,surface_pressure,precipitation,shortwave_radiation`);
    const w = await weatherRes.json();
    const cw=w.current_weather||{};
    data.atmosphere_temp=Math.min(1, Math.max(0,(cw.temperature_2m+40)/80));
    data.atmosphere_wind=Math.min(1,(cw.wind_speed_10m||0)/80);
    data.atmosphere_pressure=Math.min(1,(cw.surface_pressure-950)/150);
    data.precipitation=Math.min(1,(cw.precipitation||0)/15);
    data.solar_radiation=Math.min(1,(cw.shortwave_radiation||0)/1200);

    // Океан
    const oceanRes = await fetch(`https://marine-api.open-meteo.com/v1/marine?latitude=44.5&longitude=34.0&current=wave_height`);
    const o=await oceanRes.json();
    data.ocean=Math.min(1,(o.current?.wave_height||0)/8);

    // Землетрус
    const eqRes=await fetch('https://earthquake.usgs.gov/earthquakes/feed/v1.0/summary/all_hour.geojson');
    const eq=await eqRes.json();
    const feats=eq.features||[];
    const maxMag=feats.reduce((m,f)=>Math.max(m,f.properties?.mag||0),0);
    data.seismic=Math.min(1,(feats.length/30)+(maxMag/10*0.5));

    // Магнітне поле
    try{
      const kpRes=await fetch('https://services.swpc.noaa.gov/products/geospace/planetary-k-index-1-minute.json');
      const kpData=await kpRes.json();
      const latestKp=parseFloat(kpData[kpData.length-1]?.[1])||0;
      data.magnetic=Math.min(1,latestKp/9);
    }catch{}

    // Сонячний вітер
    try{
      const proxy='https://corsproxy.io/?';
      const solarRes=await fetch(proxy+encodeURIComponent('https://services.swpc.noaa.gov/products/solar-wind/plasma-7-day.json'));
      const sdata=await solarRes.json();
      const latest=sdata[sdata.length-1]||[];
      const speed=parseFloat(latest[3])||400;
      data.solar_wind=Math.min(1,(speed-250)/750);
    }catch{}

    // Хаос
    let vars=[];
    Object.keys(history).forEach(k=>{
      if(k==='chaos') return;
      const h=history[k];
      if(h.length<2) return;
      const mean=h.reduce((a,b)=>a+b,0)/h.length;
      const varc=h.reduce((a,b)=>a+(b-mean)**2,0)/h.length;
      vars.push(Math.sqrt(varc));
    });
    data.chaos = vars.length ? Math.min(1,vars.reduce((a,b)=>a+b,0)/vars.length*10) : 0.5;

    // Історія
    Object.keys(history).forEach(k=>{
      history[k].push(data[k]);
      if(history[k].length>HISTORY_LEN) history[k].shift();
    });

  }catch(e){ console.error(e);}
}
fetchData();
setInterval(fetchData,120000);

/* ===================== FLOW LINES ===================== */
const lines=[];
const MAX_LINES=60;
for(let i=0;i<MAX_LINES;i++){
  lines.push({
    x:Math.random()*w, y:Math.random()*h,
    vx:0, vy:0,
    phase:Math.random()*Math.PI*2,
    color: colors[i%colors.length],
    param: dataKeys[i%dataKeys.length]
  });
}

/* ===================== LOOP ===================== */
let t=0;
function loop(){
  t+=0.016;

  // фон
  ctx.fillStyle="rgba(0,0,0,0.08)";
  ctx.fillRect(0,0,w,h);

  // зірки
  stars.forEach(s=>{
    const tw=Math.sin(t*12*s.twinkle + s.x*0.008)*0.18;
    ctx.fillStyle=`rgba(255,255,255,${Math.max(0.05,s.baseAlpha+tw)})`;
    ctx.fillRect(s.x,s.y,s.size,s.size);
  });

  // лінії потоків
  lines.forEach(l=>{
    const v = data[l.param]||0.5;
    const angle = t*0.5 + l.phase;
    const speed = 0.5 + v*3 + data.chaos*2;
    l.vx += Math.cos(angle)*0.02*v;
    l.vy += Math.sin(angle)*0.02*v;
    l.x += l.vx*speed;
    l.y += l.vy*speed;
    l.vx *=0.95; l.vy*=0.95;

    // wrap around
    if(l.x>w) l.x=0; if(l.x<0) l.x=w;
    if(l.y>h) l.y=0; if(l.y<0) l.y=h;

    ctx.beginPath();
    ctx.moveTo(l.x-l.vx*5,l.y-l.vy*5);
    ctx.lineTo(l.x,l.y);
    ctx.strokeStyle=l.color;
    ctx.lineWidth=1+v*2;
    ctx.stroke();
  });

  updatePanel();
  requestAnimationFrame(loop);
}
loop();
</script>
</body>
</html>
