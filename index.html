<!DOCTYPE html>
<html lang="uk">
<head>
<meta charset="UTF-8">
<title>GEOMETRIC CHAOS · INTERLACED FORMS</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<style>
html,body{
  margin:0; padding:0;
  width:100%; height:100%;
  background:#000;
  overflow:hidden;
  font-family:"Courier New", monospace;
  color:#0af;
}
canvas{ display:block; position:fixed; inset:0; z-index:0; }
#dataPanel{
  position:fixed;
  bottom:0; left:50%;
  transform:translateX(-50%);
  width:95%; max-width:800px;
  background:rgba(0,0,0,0.5);
  color:#0f0; font-size:11px;
  padding:6px 10px;
  border-radius:6px;
  line-height:1.2;
  z-index:2;
  white-space:pre;
}
#info{
  position:fixed;
  bottom:50px; left:50%;
  transform:translateX(-50%);
  font-size:10px; opacity:0.35;
  text-align:center;
  max-width:90%;
  z-index:2;
  color:#9fe7ff;
}
</style>
</head>
<body>

<canvas id="c"></canvas>
<div id="dataPanel">ініціалізація...</div>
<div id="info">
фізико-геометрична система. симуляція реальних та модельованих даних. кожен показник — окремий об’єкт.
</div>

<script>
/* ===================== CANVAS ===================== */
const canvas=document.getElementById("c");
const ctx=canvas.getContext("2d");
let w,h;
function resize(){ w=canvas.width=innerWidth; h=canvas.height=innerHeight; }
window.addEventListener("resize",resize);
resize();

/* ===================== STARS ===================== */
const stars=[];
for(let i=0;i<400;i++){
  stars.push({
    x:Math.random()*w,
    y:Math.random()*h,
    size:Math.random()*1.5+0.5,
    baseAlpha:Math.random()*0.4+0.2,
    twinkle:Math.random()*0.02+0.005
  });
}

/* ===================== DATA ===================== */
const dataKeys = [
  "seismic","magnetic","atmosphere_wind","atmosphere_pressure","atmosphere_temp",
  "ocean","solar_radiation","solar_wind","precipitation","chaos"
];
const data={};
const history={};
const HISTORY_LEN=400;
dataKeys.forEach(k=>{data[k]=0.5; history[k]=[];});

/* ===================== COLORS ===================== */
const colors=[
  "rgba(255,80,80,0.8)","rgba(80,180,255,0.8)","rgba(80,255,160,0.8)",
  "rgba(255,180,60,0.8)","rgba(255,100,200,0.8)","rgba(100,200,255,0.8)",
  "rgba(255,240,100,0.8)","rgba(200,120,255,0.8)","rgba(100,220,255,0.8)",
  "rgba(255,255,255,0.8)"
];

/* ===================== DATA PANEL ===================== */
const dataPanel = document.getElementById("dataPanel");
function updatePanel(){
  let out="";
  dataKeys.forEach(k=>{
    out += k.padEnd(20," ") + data[k].toFixed(3) + "\n";
  });
  dataPanel.textContent = out;
}

/* ===================== DATA FETCH ===================== */
async function fetchData(){
  try{
    // Атмосфера
    const weatherRes = await fetch(`https://api.open-meteo.com/v1/forecast?latitude=50.55&longitude=30.25&current_weather=true&hourly=temperature_2m,wind_speed_10m,surface_pressure,precipitation,shortwave_radiation`);
    const w = await weatherRes.json();
    const cw=w.current_weather||{};
    data.atmosphere_temp=Math.min(1, Math.max(0,(cw.temperature_2m+40)/80));
    data.atmosphere_wind=Math.min(1,(cw.wind_speed_10m||0)/80);
    data.atmosphere_pressure=Math.min(1,(cw.surface_pressure-950)/150);
    data.precipitation=Math.min(1,(cw.precipitation||0)/15);
    data.solar_radiation=Math.min(1,(cw.shortwave_radiation||0)/1200);

    // Океан
    const oceanRes = await fetch(`https://marine-api.open-meteo.com/v1/marine?latitude=44.5&longitude=34.0&current=wave_height`);
    const o=await oceanRes.json();
    data.ocean=Math.min(1,(o.current?.wave_height||0)/8);

    // Землетрус
    const eqRes=await fetch('https://earthquake.usgs.gov/earthquakes/feed/v1.0/summary/all_hour.geojson');
    const eq=await eqRes.json();
    const feats=eq.features||[];
    const maxMag=feats.reduce((m,f)=>Math.max(m,f.properties?.mag||0),0);
    data.seismic=Math.min(1,(feats.length/30)+(maxMag/10*0.5));

    // Магнітне поле
    try{
      const kpRes=await fetch('https://services.swpc.noaa.gov/products/geospace/planetary-k-index-1-minute.json');
      const kpData=await kpRes.json();
      const latestKp=parseFloat(kpData[kpData.length-1]?.[1])||0;
      data.magnetic=Math.min(1,latestKp/9);
    }catch{}

    // Сонячний вітер
    try{
      const proxy='https://corsproxy.io/?';
      const solarRes=await fetch(proxy+encodeURIComponent('https://services.swpc.noaa.gov/products/solar-wind/plasma-7-day.json'));
      const sdata=await solarRes.json();
      const latest=sdata[sdata.length-1]||[];
      const speed=parseFloat(latest[3])||400;
      data.solar_wind=Math.min(1,(speed-250)/750);
    }catch{}

    // Хаос
    let vars=[];
    Object.keys(history).forEach(k=>{
      if(k==='chaos') return;
      const h=history[k];
      if(h.length<2) return;
      const mean=h.reduce((a,b)=>a+b,0)/h.length;
      const varc=h.reduce((a,b)=>a+(b-mean)**2,0)/h.length;
      vars.push(Math.sqrt(varc));
    });
    data.chaos = vars.length ? Math.min(1,vars.reduce((a,b)=>a+b,0)/vars.length*10) : 0.5;

    // Історія
    Object.keys(history).forEach(k=>{
      history[k].push(data[k]);
      if(history[k].length>HISTORY_LEN) history[k].shift();
    });

  }catch(e){ console.error(e);}
}
fetchData();
setInterval(fetchData,120000);

/* ===================== FIGURES ===================== */
const shapes = [
  {type:"circle",size:30,angle:0,phase:0},
  {type:"triangle",size:30,angle:0,phase:0.6},
  {type:"square",size:30,angle:0,phase:1.2},
  {type:"pentagon",size:30,angle:0,phase:1.8},
  {type:"hexagon",size:30,angle:0,phase:2.4},
  {type:"star",size:25,angle:0,phase:3.0},
  {type:"diamond",size:25,angle:0,phase:3.6},
  {type:"cross",size:25,angle:0,phase:4.2},
  {type:"ellipse",size:30,angle:0,phase:4.8},
  {type:"octagon",size:30,angle:0,phase:5.4},
];

/* ===================== DRAW SHAPE ===================== */
function drawShape(x,y,s,angle,type,color){
  ctx.save();
  ctx.translate(x,y);
  ctx.rotate(angle);
  ctx.strokeStyle=color;
  ctx.lineWidth=2;
  ctx.beginPath();
  switch(type){
    case"circle": ctx.arc(0,0,s,0,Math.PI*2); break;
    case"triangle":
      for(let i=0;i<3;i++){
        const a=i*2*Math.PI/3;
        const px=Math.cos(a)*s, py=Math.sin(a)*s;
        i===0?ctx.moveTo(px,py):ctx.lineTo(px,py);
      }
      ctx.closePath();
      break;
    case"square":
      for(let i=0;i<4;i++){
        const a=i*2*Math.PI/4+Math.PI/4;
        const px=Math.cos(a)*s, py=Math.sin(a)*s;
        i===0?ctx.moveTo(px,py):ctx.lineTo(px,py);
      }
      ctx.closePath();
      break;
    case"pentagon":
      for(let i=0;i<5;i++){
        const a=i*2*Math.PI/5-Math.PI/2;
        const px=Math.cos(a)*s, py=Math.sin(a)*s;
        i===0?ctx.moveTo(px,py):ctx.lineTo(px,py);
      }
      ctx.closePath();
      break;
    case"hexagon":
      for(let i=0;i<6;i++){
        const a=i*2*Math.PI/6;
        const px=Math.cos(a)*s, py=Math.sin(a)*s;
        i===0?ctx.moveTo(px,py):ctx.lineTo(px,py);
      }
      ctx.closePath();
      break;
    case"star":
      for(let i=0;i<5;i++){
        const a=i*2*Math.PI/5;
        const px=Math.cos(a)*s, py=Math.sin(a)*s;
        ctx.lineTo(px,py);
      }
      ctx.closePath();
      break;
    case"diamond":
      ctx.moveTo(0,-s); ctx.lineTo(s,0); ctx.lineTo(0,s); ctx.lineTo(-s,0); ctx.closePath();
      break;
    case"cross":
      ctx.moveTo(-s,0); ctx.lineTo(s,0); ctx.moveTo(0,-s); ctx.lineTo(0,s); break;
    case"ellipse":
      ctx.ellipse(0,0,s,s*0.6,0,0,Math.PI*2); break;
    case"octagon":
      for(let i=0;i<8;i++){
        const a=i*2*Math.PI/8+Math.PI/8;
        const px=Math.cos(a)*s, py=Math.sin(a)*s;
        i===0?ctx.moveTo(px,py):ctx.lineTo(px,py);
      }
      ctx.closePath();
      break;
  }
  ctx.stroke();
  ctx.restore();
}

/* ===================== LOOP ===================== */
let t=0;
function loop(){
  t+=0.016;

  // фон
  ctx.fillStyle="rgba(0,0,0,0.08)";
  ctx.fillRect(0,0,w,h);

  // зірки
  stars.forEach(s=>{
    const tw=Math.sin(t*12*s.twinkle + s.x*0.008)*0.18;
    ctx.fillStyle=`rgba(255,255,255,${Math.max(0.05,s.baseAlpha+tw)})`;
    ctx.fillRect(s.x,s.y,s.size,s.size);
  });

  // фігури по даних
  const cx=w/2, cy=h/2;
  shapes.forEach((s,i)=>{
    const v=data[dataKeys[i]]||0.5;
    const angle=t*0.5 + s.phase;
    const radius=50+v*200 + 30*Math.sin(t+i);
    const x=cx+Math.cos(angle)*(radius);
    const y=cy+Math.sin(angle)*(radius);
    const size=20 + v*30;
    drawShape(x,y,size,angle,s.type,colors[i%colors.length]);
  });

  updatePanel();
  requestAnimationFrame(loop);
}
loop();
</script>
</body>
</html>
